// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define("kopi/logging", function(require, exports, module) {
    var Logger, LoggerError, array, exceptions, logger, loggers, object, settings;
    array = require("kopi/utils/array");
    object = require("kopi/utils/object");
    settings = require("kopi/settings");
    exceptions = require("kopi/exceptions");
    LoggerError = (function(_super) {

      __extends(LoggerError, _super);

      function LoggerError() {
        return LoggerError.__super__.constructor.apply(this, arguments);
      }

      return LoggerError;

    })(exceptions.ValueError);
    loggers = {};
    /*
      Improve original console with tag, time and extra handlers
    
      # TODO Implement logging handler mechanism like Python
    */

    Logger = (function() {
      var accumulators, console, defineMethod, level, levels, proto, send, start, timers;

      start = (window.__KOPI__START_TIME || (window.__KOPI__START_TIME = new Date()));

      timers = {};

      accumulators = {};

      levels = {
        log: 0,
        debug: 1,
        info: 2,
        warn: 3,
        error: 4
      };

      console = window.console;

      /*
          send log to logging handler
      
          @param  {String}  name
          @param  {String}  level
          @param  {String}  message
          @param  {Hash}    options
      */


      send = function(name, level, message, options) {
        var action, seconds;
        if (options == null) {
          options = {};
        }
        if (!(level in levels)) {
          throw new LoggerError("Invalid logger level: " + level);
        }
        options = object.extend({}, settings.kopi.logging, options);
        if (levels[level] < options.level) {
          return false;
        }
        seconds = Math.round(new Date() - start) / 1000;
        if (options.console && console) {
          action = level in console ? level : "log";
          if (options.raw) {
            console[action]("[" + seconds + "s] [" + name + "]");
            return console[action](message);
          } else {
            return console[action]("[" + seconds + "s] [" + name + "] " + message);
          }
        }
      };

      /*
          Constructor for logger
      
          @constructor
          @param {String} name
      */


      function Logger(name) {
        if (!name) {
          throw new LoggerError("Logger must have a name");
        }
        this._name = name;
        this._disabled = false;
        loggers[name] = this;
      }

      /*
          Return name of logger
      */


      Logger.prototype.name = function() {
        return this._name;
      };

      /*
          Enable logger
      */


      Logger.prototype.enable = function() {
        this._disabled = false;
        return this;
      };

      /*
          Disable logger
      */


      Logger.prototype.disable = function() {
        this._disabled = true;
        return this;
      };

      /*
          Start a timer under the given name
      
          @param  {String}  name
          @param  {Hash}    options
      */


      Logger.prototype.time = function(name, options) {
        var key, timer;
        if (options == null) {
          options = {};
        }
        if (this._disabled) {
          return this;
        }
        key = "" + this._name + ":" + name;
        timer = timers[key];
        if (timer) {
          return;
        }
        send(this._name, "debug", "" + name + " started.");
        timers[key] = new Date();
        if (options.accumulate) {
          accumulators[key] || (accumulators[key] = []);
        }
        return this;
      };

      /*
          Stop a timer created by a call to Logger.time(name)
      
          @param  {String}  name
          @param  {Hash}    options
      */


      Logger.prototype.timeEnd = function(name, options) {
        var key, message, time, timer;
        if (options == null) {
          options = {};
        }
        key = "" + this._name + ":" + name;
        timer = timers[key];
        if (!timer) {
          return;
        }
        time = new Date() - timer;
        message = "" + name + " stoped. spent " + time + "ms.";
        if (options.accumulate) {
          accumulators[key].push(time);
          message += " total " + (array.sum(accumulators[key])) + "ms. average " + (array.average(accumulators[key])) + "ms.";
        }
        send(this._name, "debug", message);
        timers[key] = null;
        return this;
      };

      proto = Logger.prototype;

      defineMethod = function(level) {
        return proto[level] = function(message, options) {
          if (this._disabled) {
            return this;
          }
          send(this._name, level, message, options);
          return this;
        };
      };

      for (level in levels) {
        defineMethod(level);
      }

      return Logger;

    })();
    logger = new Logger("kopi");
    return {
      debug: function() {
        return logger.debug.apply(logger, arguments);
      },
      info: function() {
        return logger.info.apply(logger, arguments);
      },
      warn: function() {
        return logger.warn.apply(logger, arguments);
      },
      error: function() {
        return logger.error.apply(logger, arguments);
      },
      time: function() {
        return logger.time.apply(logger, arguments);
      },
      timeEnd: function() {
        return logger.timeEnd.apply(logger, arguments);
      },
      /*
        Factory method for loggers
      */

      logger: function(name) {
        if (name) {
          return loggers[name] || new Logger(name);
        } else {
          return logger;
        }
      }
    };
  });

}).call(this);
