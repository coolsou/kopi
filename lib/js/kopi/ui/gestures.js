// Generated by CoffeeScript 1.3.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  define("kopi/ui/gestures", function(require, exports, module) {
    var Base, EventEmitter, Pan, Pinch, Rotation, Tap, body, doc, klass, math, support, win;
    EventEmitter = require("kopi/events").EventEmitter;
    klass = require("kopi/utils/klass");
    support = require("kopi/utils/support");
    win = window;
    doc = document;
    body = doc.body;
    math = Math;
    /*
      Base class for concrete gesture recognizer classes.
    
      A gesture recognizer decouples the logic for recognizing a gesture
      and acting on that recognition
    
      This is inspired by UIGestureRecognizer of iOS
    */

    Base = (function(_super) {

      __extends(Base, _super);

      klass.configure(Base, {
        preventDefault: true,
        stopPropagation: false
      });

      function Base(widget, options) {
        if (options == null) {
          options = {};
        }
        this._widget = widget;
        this.configure(options);
      }

      Base.prototype.ontouchstart = function(e) {
        if (this._options.preventDefault) {
          e.preventDefault();
        }
        if (this._options.stopPropagation) {
          return e.stopPropagation();
        }
      };

      Base.prototype.ontouchmove = function(e) {
        if (this._options.preventDefault) {
          e.preventDefault();
        }
        if (this._options.stopPropagation) {
          return e.stopPropagation();
        }
      };

      Base.prototype.ontouchend = function(e) {
        if (this._options.preventDefault) {
          e.preventDefault();
        }
        if (this._options.stopPropagation) {
          return e.stopPropagation();
        }
      };

      Base.prototype.ontouchcancel = function(e) {
        return this.ontouchend.call(this, e);
      };

      /*
          get the x and y positions from the event object
      
          @param {Event} event
          @return {Array}  [{ x: int, y: int }]
      */


      Base.prototype._getPositionfromEvent = function(e, multiTouch) {
        var pos, touch, touches;
        if (multiTouch == null) {
          multiTouch = false;
        }
        e || (e = win.event);
        if (!support.touch) {
          pos = [
            {
              x: e.pageX,
              y: e.pageY
            }
          ];
        } else {
          touches = e.touches.length > 0 ? e.touches : e.changedTouches;
          pos = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = touches.length; _i < _len; _i++) {
              touch = touches[_i];
              _results.push({
                x: touch.pageX,
                y: touch.pageY
              });
            }
            return _results;
          })();
        }
        if (multiTouch) {
          return pos;
        } else {
          return pos[0];
        }
      };

      return Base;

    })(EventEmitter);
    /*
      Tap Gesture Recognizer
    */

    Tap = (function(_super) {

      __extends(Tap, _super);

      function Tap() {
        return Tap.__super__.constructor.apply(this, arguments);
      }

      Tap.TAP_START = "tapstart";

      Tap.TAP_EVENT = "tap";

      Tap.TAP_HOLD_EVENT = "taphold";

      Tap.TAP_RELEASE_EVENT = "taprelease";

      Tap.configure({
        minTaps: 1,
        minTouches: 1,
        movement: 20,
        timeout: 500
      });

      Tap.prototype.ontouchstart = function(e) {
        var pos;
        Tap.__super__.ontouchstart.apply(this, arguments);
        this._moved = false;
        this._holded = false;
        pos = this._getPositionfromEvent(e, false);
        this._posX = pos.x;
        this._posY = pos.y;
        this._widget.emit(this.constructor.TAP_START, [e]);
        return this._setHoldTimeout();
      };

      Tap.prototype.ontouchmove = function(e) {
        var deltaX, deltaY, pos, threshold;
        Tap.__super__.ontouchmove.apply(this, arguments);
        threshold = this._options.movement;
        pos = this._getPositionfromEvent(e, false);
        deltaX = pos.x - this._posX;
        deltaY = pos.y - this._posY;
        if (!this._moved && ((math.abs(deltaX) > threshold) || (math.abs(deltaY) > threshold))) {
          this._moved = true;
        }
        if (!this._holded) {
          return this._setHoldTimeout();
        }
      };

      Tap.prototype.ontouchend = function(e) {
        Tap.__super__.ontouchend.apply(this, arguments);
        this._clearHoldTimeout();
        this._widget.emit(this.constructor.TAP_RELEASE_EVENT);
        if (!this._holded && !this._moved) {
          if (e) {
            e.preventDefault();
            e.stopPropagation();
          }
          this._widget.emit(this.constructor.TAP_EVENT);
          return false;
        }
      };

      Tap.prototype._setHoldTimeout = function() {
        var holdFn,
          _this = this;
        if (this._holdTimer) {
          clearTimeout(this._holdTimer);
        }
        holdFn = function() {
          _this._holded = true;
          _this._widget.emit(_this.constructor.TAP_HOLD_EVENT);
          return _this._clearHoldTimeout();
        };
        return this._holdTimer = setTimeout(holdFn, this._options.timeout);
      };

      Tap.prototype._clearHoldTimeout = function() {
        if (this._holdTimer) {
          clearTimeout(this._holdTimer);
          return this._holdTimer = null;
        }
      };

      return Tap;

    })(Base);
    Pan = (function(_super) {

      __extends(Pan, _super);

      function Pan() {
        return Pan.__super__.constructor.apply(this, arguments);
      }

      return Pan;

    })(Base);
    Pinch = (function(_super) {

      __extends(Pinch, _super);

      function Pinch() {
        return Pinch.__super__.constructor.apply(this, arguments);
      }

      return Pinch;

    })(Base);
    Rotation = (function(_super) {

      __extends(Rotation, _super);

      function Rotation() {
        return Rotation.__super__.constructor.apply(this, arguments);
      }

      return Rotation;

    })(Base);
    return {
      Base: Base,
      Tap: Tap,
      Pinch: Pinch,
      Rotation: Rotation,
      Pan: Pan
    };
  });

}).call(this);
