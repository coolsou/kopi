// Generated by CoffeeScript 1.3.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  define("kopi/ui/draggable", function(require, exports, module) {
    var Draggable, RE_MATRIX, TRANSFORM, TRANSFORM_ORIGIN, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, css, events, logger, logging, math, text, touchable;
    logging = require("kopi/logging");
    css = require("kopi/utils/css");
    events = require("kopi/utils/events");
    text = require("kopi/utils/text");
    touchable = require("kopi/ui/touchable");
    math = Math;
    logger = logging.logger(module.id);
    TRANSITION_PROPERTY = css.experimental("transition-property");
    TRANSITION_DURATION = css.experimental("transition-duration");
    TRANSITION_TIMING_FUNCTION = css.experimental("transition-timing-function");
    TRANSFORM_ORIGIN = css.experimental("transform-origin");
    TRANSFORM = css.experimental("transform");
    RE_MATRIX = /[^0-9-.,]/g;
    /*
      A widget can be dragged by mouse or finger
    */

    Draggable = (function(_super) {
      var kls;

      __extends(Draggable, _super);

      Draggable.name = 'Draggable';

      function Draggable() {
        return Draggable.__super__.constructor.apply(this, arguments);
      }

      kls = Draggable;

      kls.RESIZE_EVENT = "resize";

      kls.TRANSITION_END_EVENT = "transitionend";

      kls.TRANSITION_PROPERTY_STYLE = css.experimental("transform");

      kls.TRANSITION_DURATION_STYLE = "0ms";

      kls.TRANSITION_TIMING_FUNCTION_STYLE = "cubic-bezier(0.33,0.66,0.66,1)";

      kls.TRANSFORM_ORIGIN_STYLE = "0 0";

      kls.TRANSFORM_STYLE = "" + css.TRANSLATE_OPEN + "{x}px,{y}px" + css.TRANSLATE_CLOSE;

      kls.widgetName("Draggable");

      Draggable.prototype.moveTo = function(x, y, duration) {
        var self, step;
        self = this;
        self._stopAnimation();
        step = {
          x: x,
          y: y,
          duration: duration || 0
        };
        self._steps.push(step);
        return self._animate();
      };

      Draggable.prototype.onskeleton = function() {
        var cls, self, styles;
        cls = this.constructor;
        self = this;
        styles = {};
        styles[TRANSITION_PROPERTY] = cls.TRANSITION_PROPERTY_STYLE;
        styles[TRANSITION_DURATION] = cls.TRANSITION_DURATION_STYLE;
        styles[TRANSITION_TIMING_FUNCTION] = cls.TRANSITION_TIMING_FUNCTION_STYLE;
        styles[TRANSFORM_ORIGIN] = cls.TRANSFORM_ORIGIN_STYLE;
        styles[TRANSFORM] = text.format(cls.TRANSFORM_STYLE, {
          x: 0,
          y: 0
        });
        self.element.css(styles);
        return Draggable.__super__.onskeleton.apply(this, arguments);
      };

      Draggable.prototype.ontouchstart = function(e, event) {
        var cls, point, self;
        cls = this.constructor;
        self = this;
        self._moved = false;
        self._animating = false;
        self._deltaX || (self._deltaX = 0);
        self._deltaY || (self._deltaY = 0);
        point = self._points(event);
        self._pointX = point.pageX;
        self._pointY = point.pageY;
        self._timeStamp = self._startTime = point.timeStamp || new Date().getTime();
        self._duration(0);
        return Draggable.__super__.ontouchstart.apply(this, arguments);
      };

      Draggable.prototype.ontouchmove = function(e, event) {
        var options, point, self, timestamp;
        event.preventDefault();
        event.stopPropagation();
        self = this;
        options = self._options;
        point = self._points(event);
        self._deltaX += point.pageX - self._pointX;
        self._deltaY += point.pageY - self._pointY;
        self._pointX = point.pageX;
        self._pointY = point.pageY;
        self._moved = true;
        self._position(self._deltaX, self._deltaY);
        logger.debug("x: " + self._deltaX + ", y: " + self._deltaY);
        timestamp = point.timeStamp || new Date().getTime();
        if (timestamp - self._startTime > 300) {
          self._startTime = timestamp;
        }
        return Draggable.__super__.ontouchmove.apply(this, arguments);
      };

      Draggable.prototype.ontouchend = function(e, event) {
        var point, self;
        self = this;
        point = self._points(event);
        if (!self._moved) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        return Draggable.__super__.ontouchend.apply(this, arguments);
      };

      Draggable.prototype.ontouchcancel = function(e, event) {
        this.ontouchend.apply(this, arguments);
        return Draggable.__super__.ontouchcancel.apply(this, arguments);
      };

      Draggable.prototype._resetPosition = function(duration) {
        var self;
        self = this;
        return self.moveTo(self._deltaX, self._deltaY, duration);
      };

      Draggable.prototype._position = function(x, y) {
        var cls, self;
        cls = this.constructor;
        self = this;
        self.element.css(TRANSFORM, text.format(cls.TRANSFORM_STYLE, {
          x: x,
          y: y
        }));
        self._x = x;
        self._y = y;
        return self;
      };

      Draggable.prototype._duration = function(duration) {
        this.element.css(TRANSITION_DURATION, duration + 'ms');
        return this;
      };

      Draggable.prototype._stopAnimation = function() {
        this._steps = [];
        this._moved = false;
        this._animating = false;
        return this;
      };

      Draggable.prototype._animate = function() {
        var cls, self, startTime, step, transitionEndFn;
        cls = this.constructor;
        self = this;
        if (self._animating) {
          return;
        }
        if (!self._steps.length) {
          self._resetPosition(400);
          return self;
        }
        startTime = new Date().getTime();
        step = self._steps.shift();
        self._animating = true;
        self._moved = true;
        self._duration(step.duration)._position(step.x, step.y);
        self._animating = false;
        if (step.duration) {
          transitionEndFn = function(e) {
            e.preventDefault();
            e.stopPropagation();
            return self.emit(cls.TRANSITION_END_EVENT);
          };
          self.element.bind(events.WEBKIT_TRANSITION_END_EVENT, transitionEndFn);
        } else {
          self._resetPosition(0);
        }
        return self;
      };

      return Draggable;

    })(touchable.Touchable);
    return {
      Draggable: Draggable
    };
  });

}).call(this);
